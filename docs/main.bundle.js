(()=>{"use strict";var e={33:(e,n)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.camera=void 0,n.camera="\nstruct Camera {\n    vec3 lookFrom;\n    vec3 lowerLeftCorner;\n    vec3 horizontal;\n    vec3 vertical;\n};\n\nCamera cameraInit(vec3 lookFrom, vec3 lookAt, vec3 vUp, float vFov) {\n    float aspectRatio = u_resolution.x / u_resolution.y;\n    float theta = radians(vFov);\n    float h = tan(theta / 2.0);\n    float viewportHeight = 2.0 * h;\n    float viewportWidth = aspectRatio * viewportHeight;\n    \n    vec3 w = normalize(lookFrom - lookAt);\n    vec3 u = normalize(cross(vUp, w));\n    vec3 v = cross(w, u);\n    \n    vec3 horizontal = u * viewportWidth;\n    vec3 vertical = v * viewportHeight;\n    vec3 lowerLeftCorner = lookFrom - (horizontal / 2.0) - (vertical / 2.0) - w;\n    return Camera(lookFrom, lowerLeftCorner, horizontal, vertical);\n}\n\nRay cameraGetRay(Camera camera, vec2 uv) {\n    return rayInit(camera.lookFrom, camera.lowerLeftCorner + uv.x * camera.horizontal + uv.y * camera.vertical - camera.lookFrom);\n}\n"},57:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.PreviewSection=void 0;const a=t(697);n.PreviewSection=class{constructor(){this.renderer=new a.Renderer(320,240),this.cameraYSlider=$('<input type="range" min="0.001" max="10.0" step="0.00001" value="2.0">').on("input",(()=>this.preview())),this.cameraXRotSlider=$('<input type="range" min="-0.999" max="0.999" step="0.00001" value="0.2">').on("input",(()=>this.preview())),this.mountainTimeSlider=$('<input type="range" min="0" max="20.0" step="0.00001" value="0">').on("input",(()=>this.preview())),this.starZRotSlider=$('<input type="range" min="-0.999" max="0.999" step="0.00001" value="0.4">').on("input",(()=>this.preview())),this.starXRotSlider=$('<input type="range" min="-0.999" max="0.999" step="0.00001" value="0.0">').on("input",(()=>this.preview())),this.milkyScaleSlider=$('<input type="range" min="0.1" max="5.0" step="0.00001" value="1.0">').on("input",(()=>this.preview())),this.milkyBlendSlider=$('<input type="range" min="0.0" max="5.0" step="0.00001" value="1.0">').on("input",(()=>this.preview())),this.fbmScaleSlider=$('<input type="range" min="0.00001" max="0.01" step="0.00001" value="0.003">').on("input",(()=>this.preview())),this.fbmDepthSlider=$('<input type="range" min="0.1" max="1" step="0.00001" value="0.63">').on("input",(()=>this.preview())),this.fbmThresholdSlider=$('<input type="range" min="0.1" max="1" step="0.00001" value="0.8">').on("input",(()=>this.preview())),this.cloudTimeSlider=$('<input type="range" min="0.001" max="3000.0" step="0.00001" value="0.0">').on("input",(()=>this.preview())),this.cloudMinYSlider=$('<input type="range" min="100" max="400" step="0.00001" value="100">').on("input",(()=>this.preview())),this.cloudThicknessSlider=$('<input type="range" min="10" max="700" step="0.000011" value="50">').on("input",(()=>this.preview())),this.cloudAlphaScaleSlider=$('<input type="range" min="0" max="0.05" step="0.00001" value="0.04">').on("input",(()=>this.preview())),this.waveFactorSlider=$('<input type="range" min="0.001" max="0.1" step="0.00001" value="0.02">').on("input",(()=>this.preview())),this.waveScaleSlider=$('<input type="range" min="0.000" max="1.5" step="0.00001" value="1.0">').on("input",(()=>this.preview())),this.waveTimeSlider=$('<input type="range" min="0.000" max="10.0" step="0.00001" value="0.0">').on("input",(()=>this.preview())),this.element=$("<section>").append($("<h2>").text("【STEP.1】 各種設定を行ってください"),$('<div class="preview-container">').append($(this.renderer.webGlCanvas.canvas).on("click",(()=>{console.log(JSON.stringify(this.getRenderParams(0)))})),$('<div class="params">').append($("<div>").text("カメラ上下位置："),this.cameraYSlider,$("<div>").text("カメラ上下向き："),this.cameraXRotSlider,$("<div>").text("山形状："),this.mountainTimeSlider,$("<div>").text("天球Z軸回転："),this.starZRotSlider,$("<div>").text("天球X軸回転："),this.starXRotSlider,$("<div>").text("天の川大きさ："),this.milkyScaleSlider,$("<div>").text("天の川濃さ："),this.milkyBlendSlider,$("<div>").text("雲の高度："),this.cloudMinYSlider,$("<div>").text("雲の濃さ："),this.cloudAlphaScaleSlider,$("<div>").text("雲の厚み："),this.cloudThicknessSlider,$("<div>").text("雲の細かさ："),this.fbmScaleSlider,$("<div>").text("雲の細部強調："),this.fbmDepthSlider,$("<div>").text("雲の量："),this.fbmThresholdSlider,$("<div>").text("雲の時間："),this.cloudTimeSlider,$("<div>").text("湖面ゆらぎ強さ："),this.waveFactorSlider,$("<div>").text("湖面ゆらぎサイズ："),this.waveScaleSlider,$("<div>").text("湖面の時間："),this.waveTimeSlider))),this.preview()}getRenderParams(e){let n=0,t=0,a=0,i=1;switch(e){case 0:n=40,t=10,a=2;break;default:case 1:n=100,t=10,a=2,i=4;break;case 2:n=300,t=12,a=6,i=4;break;case 3:n=500,t=20,a=10,i=4}return{cameraY:parseFloat(this.cameraYSlider.val()+""),cameraXRot:-parseFloat(this.cameraXRotSlider.val()+"")*Math.PI/2,mountainTime:parseFloat(this.mountainTimeSlider.val()+""),starZRot:parseFloat(this.starZRotSlider.val()+"")*Math.PI/2,starXRot:-parseFloat(this.starXRotSlider.val()+"")*Math.PI/2,milkyScale:parseFloat(this.milkyScaleSlider.val()+""),milkyBlend:parseFloat(this.milkyBlendSlider.val()+""),fbmScale:parseFloat(this.fbmScaleSlider.val()+""),fbmDepth:parseFloat(this.fbmDepthSlider.val()+""),fbmThreshold:parseFloat(this.fbmThresholdSlider.val()+""),cloudTime:parseFloat(this.cloudTimeSlider.val()+""),cloudMinY:parseFloat(this.cloudMinYSlider.val()+""),cloudThickness:parseFloat(this.cloudThicknessSlider.val()+""),cloudAlphaScale:parseFloat(this.cloudAlphaScaleSlider.val()+""),waveFactor:parseFloat(this.waveFactorSlider.val()+""),waveScale:parseFloat(this.waveScaleSlider.val()+""),waveTime:parseFloat(this.waveTimeSlider.val()+""),cloudMaxSteps:n,fbmMaxSteps:t,fbmMinSteps:a,sampleCount:i}}preview(){this.renderer.render(this.getRenderParams(0))}}},63:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.RenderSection=void 0;const a=t(697);n.RenderSection=class{constructor(e){this.renderer=new a.Renderer(1,1),this.widthInput=$('<input type="number" min="1" value="800">'),this.heightInput=$('<input type="number" min="1" value="600">'),this.resultDiv=$('<div class="render-result">'),this.qualitySelect=$("<select>").append($('<option value="0">').text("低"),$('<option value="1" selected>').text("中"),$('<option value="2">').text("高"),$('<option value="3">').text("最高")),this.element=$("<section>").append($("<h2>").text("【STEP.2】 問題無ければ[画像生成]ボタンを押してください"),$('<div class="render-contents">').append($('<div class="params">').append($("<div>").text("出力解像度："),$('<div class="resolution">').append(this.widthInput,$("<div>").text("×"),this.heightInput),$("<div>").text("品質："),this.qualitySelect),$("<button>").text("画像生成").on("click",(()=>e())),$("<ul>").append(["スマホでは品質や解像度を上げると正常に動作しない場合があります。なるべくハイスペックなPCでお試しください。","画像が生成されたら画像を右クリック（長押し）してコピーや保存を行ってください。"].map((e=>$("<li>").text(e)))),this.resultDiv))}render(e){const n=parseInt(this.qualitySelect.val()+""),t=e.getRenderParams(n),a=Math.max(Math.floor(parseInt(this.widthInput.val()+"")),1),i=Math.max(Math.floor(parseInt(this.heightInput.val()+"")),1);this.resultDiv.empty(),this.renderer.webGlCanvas.resize(a,i),this.renderer.render(t);const o=new Image;o.src=this.renderer.webGlCanvas.canvas.toDataURL("image/png"),this.resultDiv.append(o)}}},108:(e,n)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.defines=void 0,n.defines="\nprecision highp float;\nprecision highp int;\n\nuniform vec2 u_resolution;\n\nuniform float u_cameraY;\nuniform float u_cameraXRot;\nuniform float u_mountainTime;\nuniform float u_starZRot;\nuniform float u_starXRot;\nuniform float u_milkyScale;\nuniform float u_milkyBlend;\n\nuniform float u_fbmScale;\nuniform float u_fbmDepth;\nuniform float u_fbmThreshold;\nuniform float u_cloudTime;\nuniform float u_cloudMinY;\nuniform float u_cloudThickness;\nuniform float u_cloudAlphaScale;\n\nuniform float u_waveFactor;\nuniform float u_waveScale;\nuniform float u_waveTime;\n\nuniform int u_fbmMaxSteps;\nuniform int u_fbmMinSteps;\nuniform int u_cloudMaxSteps;\nuniform int u_sampleCount;\n\nconst float PI = 3.14159265359;\n"},136:(e,n)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.ray=void 0,n.ray="\nstruct Ray {\n    // レイの原点\n    vec3 origin;\n    // レイの方向（単位ベクトル）\n    vec3 direction;\n};\n\n// レイ初期化\nRay rayInit(vec3 origin, vec3 direction) {\n    return Ray(origin, normalize(direction));\n}\n\n// レイの進行度tにおける座標を取得\nvec3 rayAt(Ray ray, float t) {\n    return ray.origin + t * ray.direction;\n}\n"},157:(e,n)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.cloud=void 0,n.cloud="\n\nvec3 cameraOrigin;\n\n// 雲をサンプリング\nfloat sampleCloudDensity(vec3 p) {\n    float res = 0.0;\n\n    // 近いところは回数を増やしたい\n    float dist = distance(cameraOrigin, p);\n    int steps = int(mix(float(u_fbmMaxSteps), float(u_fbmMinSteps), clamp(dist / 3000.0, 0.0, 1.0)));\n\n    p += vec3(8.0, 1.0, 4.0) * u_cloudTime;\n\n    for (int i = 0; i < 100; i++) {\n        if (i >= steps) {\n            break;\n        }\n    \n        float scale = u_fbmScale * pow(2.0, float(i));\n        float depth = pow(u_fbmDepth, float(i));\n        float noise = snoise(p * scale);\n        if (i == 0) {\n            noise -= (1.0 - u_fbmThreshold);\n        }\n        res += noise * depth;\n    }\n    return res;\n}\n\nfloat saturate(float f) {\n   return clamp(f, 0.0, 1.0);\n}\n\n// Yが指定した値になるときのtを求めます。負の値なら存在しません。\nfloat calcHitAtY(float y, Ray ray) {\n    if (ray.direction.y == 0.0) { return -1.0; }\n    return (y - ray.origin.y) / ray.direction.y;\n}\n\n// レイマーチングで雲の色を算出します。\nvec4 getCloudColor(Ray ray) {\n    if (ray.direction.y < 0.0) {\n        ray.direction.y = -ray.direction.y;\n    }\n\n    // 透明度 1で完全透明、0で不透明\n    float transmittance = 1.0;\n    // 密度の累積\n    float accumulatedDensity = 0.0; \n\n    float tMin = calcHitAtY(u_cloudMinY, ray);\n    float tMax = calcHitAtY(u_cloudMinY + u_cloudThickness, ray);\n    if (tMin < 0.0 || tMax < 0.0) { return vec4(0.0); }\n    \n    float stepSize = (tMax - tMin) / float(u_cloudMaxSteps);\n\n\n    float t = tMin;\n    vec3 p = rayAt(ray, tMin);\n    float opacity = smoothstep(-1000.0, -300.0, p.z);\n    vec3 pStep = ray.direction * stepSize;\n\n    for (int i = 0; i < 1000; i++) {\n        if (i >= u_cloudMaxSteps || p.z < -1100.0) {\n            break;\n        }\n\n        float density = sampleCloudDensity(p);\n        \n        // 密度が小さすぎる値は無視します。\n        if (density > 0.001) {\n            float alpha = saturate(density * stepSize * u_cloudAlphaScale);\n            accumulatedDensity += alpha * transmittance;\n            transmittance *= 1.0 - alpha;\n        }\n\n        // 不透明度になってきたら計算を終了します。\n        if (transmittance < 0.01) {\n            break;\n        }\n\n        p += pStep;\n    }\n\n    return vec4(mix(vec3(0.5), vec3(0.1), accumulatedDensity), accumulatedDensity * opacity);\n}\n"},270:(e,n)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.skyBackgroundColor=void 0,n.skyBackgroundColor="\n\nconst vec3 sky4 = vec3(0.0 / 255.0, 0.0 / 255.0, 0.0 / 255.0);\nconst vec3 sky3 = vec3(5.0 / 255.0, 16.0 / 255.0, 46.0 / 255.0);\nconst vec3 sky2 = vec3(16.0 / 255.0, 39.0 / 255.0, 80.0 / 255.0);\nconst vec3 sky1 = vec3(160.0 / 255.0, 50.0 / 255.0, 50.0 / 255.0);\nconst float skyGrad1 = 0.1;\nconst float skyGrad2 = 0.2;\n\n// 背景の色\nvec3 getSkyBackgroundColor(Ray ray) {\n    float y = ray.direction.y;\n\n    if (y < skyGrad1) {\n        return mix(sky1, sky2, y / skyGrad1);\n    } else if (y < skyGrad2) {\n        float t = (y - skyGrad1) / (skyGrad2 - skyGrad1);\n        return mix(sky2, sky3, t);\n    } else {\n        float t = (y - skyGrad2) / (0.5 - skyGrad2);\n        return mix(sky3, sky4, t);\n    }\n}\n"},277:(e,n)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.ReadmeSection=void 0,n.ReadmeSection=class{constructor(){this.element=$("<section>").append($("<h2>").text("【STEP.0】 お読みください"),$("<div>").append($("<ul>").append($("<li>").text("星空の画像を計算で生成します。"),$("<li>").text("生成された画像の著作権は利用者に帰属します。商用利用可能です（クレジット表記などは歓迎いたします）。"),$("<li>").html("WebGLを使用しています。NVIDIAの良いグラボが有ると快適に動作いたします。PC推奨。"),$("<li>").html('ソースコードはこちら：<a href="https://github.com/takabosoft/starry-sky-gen" target="_blank">https://github.com/takabosoft/starry-sky-gen</a>'))))}}},308:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.buildFragmentShader=function(){return`${o.defines}\n${l.ray}\n${a.camera}\n${s.simplexNoise}\n${r.matrix}\n${c.skyBackgroundColor}\n${u.stars}\n${i.cloud}\n\nfloat getMountainShadow(Ray ray) {\n    vec3 mountainUnit = normalize(vec3(ray.direction.x, 0, ray.direction.z));\n    float noise = fbm(8, vec3(mountainUnit.x, u_mountainTime, mountainUnit.z) * 1.4, 0.8, 2.0, 1.0, 0.51);\n    float mountainHeight = pow(noise, 2.0) * 10.0 + 4.5;\n    float dis = 100.0;\n\n    // 角度の差でスムージング\n    float mountainY = normalize(vec3(mountainUnit.x * dis, mountainHeight, mountainUnit.z * dis)).y;\n    float delta = 0.001; // この幅を調整すると影の「ぼかし具合」が変わる\n    return smoothstep(mountainY - delta, mountainY + delta, ray.direction.y);\n}\n\n// レイ方向の色を取得します。\nvec3 getWorldColor(Ray ray) {\n    vec3 col = vec3(0.0);\n    col += getStarsColor(ray);\n    col += getSkyBackgroundColor(ray);\n\n    vec4 cloud = getCloudColor(ray);\n    col = mix(col, cloud.rgb, cloud.a);\n\n    col *= getMountainShadow(ray);\n\n    // ガンマ値補正\n    col = pow(col, vec3(0.8));\n    return col;\n}\n\nvec3 getLakeColor(Ray ray) {\n    float t = -ray.origin.y / ray.direction.y;\n    if (ray.direction.y < 0.0 && t > 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.direction;\n        \n        // 波紋パターンを生成\n        float noiseX = snoise(vec3(hitPoint.x * u_waveScale, hitPoint.z * u_waveScale, u_waveTime)) * u_waveFactor;\n        float noiseZ = snoise(vec3(hitPoint.x * u_waveScale + 100.0, hitPoint.z * u_waveScale, u_waveTime)) * u_waveFactor;\n        \n        // 法線\n        vec3 normal = normalize(vec3(-noiseX, 1.0, -noiseZ));\n        \n        vec3 reflectedDir = reflect(ray.direction, normal);\n        \n        // レイを反射方向に更新\n        ray.origin = hitPoint + normal * 0.001; // 自己交差を避けるための微小オフセット\n        ray.direction = reflectedDir;\n\n        return getWorldColor(ray) * 0.7;\n    }\n    return vec3(0.0);\n}\n\nvec3 getColor(Camera cam) {\n    Ray ray = cameraGetRay(cam, gl_FragCoord.xy / (u_resolution - 1.0));\n\n    // レイがy=0と交わる場合は反射を行う　水面のように揺らぐ\n    float t = -ray.origin.y / ray.direction.y;\n    if (ray.direction.y < 0.0 && t > 0.0) {\n        // 湖面だけアンチエイリアシング対応（星空の方は暗くなるので掛けない）\n        \n        vec3 col = vec3(0.0);\n        for (int i = 0; i < 40; i++) {\n            if (i >= u_sampleCount) { break; }\n            float xOffset = rand(float(i));\n            float yOffset = rand(float(i) + 100.0);\n            col += getLakeColor(cameraGetRay(cam, (gl_FragCoord.xy + vec2(xOffset, yOffset)) / (u_resolution - 1.0)));\n        }\n        return col / float(u_sampleCount);\n    } else {\n        return getWorldColor(ray);\n    }\n}\n\nvoid main() {\n    vec3 lookFrom = vec3(0.0, u_cameraY, +5.0);\n    cameraOrigin = lookFrom;\n    vec3 lookAt = lookFrom + rotateX(u_cameraXRot) * vec3(0.0, 0.0, -1.0);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n\n    Camera cam = cameraInit(lookFrom, lookAt, vUp, 60.0);\n    gl_FragColor = vec4(getColor(cam), 1.0);\n}\n`};const a=t(33),i=t(157),o=t(108),r=t(819),l=t(136),s=t(674),c=t(270),u=t(585)},453:(e,n)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.WebGLCanvas=void 0,n.WebGLCanvas=class{constructor(e,n,t){this.fragmentShaderSource=t,this.canvas=$("<canvas>")[0],this.canvas.width=e,this.canvas.height=n;const a=this.canvas.getContext("webgl",{preserveDrawingBuffer:!0});if(!a)throw alert("WebGLの初期化に失敗"),"WebGLの初期化に失敗";this.gl=a,this.setupWebGL()}get isContextLost(){return this.gl.isContextLost()}setupWebGL(){const e=this.gl,n=this.createShader(e.VERTEX_SHADER,"\nattribute vec4 a_position;\nvoid main() {\n    gl_Position = a_position;\n}\n"),t=this.createShader(e.FRAGMENT_SHADER,this.fragmentShaderSource),a=e.createProgram();this.program=a,e.attachShader(a,n),e.attachShader(a,t),e.linkProgram(a),e.getProgramParameter(a,e.LINK_STATUS)||console.error("Program link error:",e.getProgramInfoLog(a)),e.useProgram(a);const i=new Float32Array([-1,-1,1,-1,-1,1,1,1]),o=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,o),e.bufferData(e.ARRAY_BUFFER,i,e.STATIC_DRAW);const r=e.getAttribLocation(a,"a_position");e.vertexAttribPointer(r,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(r),this.uResolutionLocation=e.getUniformLocation(a,"u_resolution"),e.uniform2f(this.uResolutionLocation,this.canvas.width,this.canvas.height)}getUniformLocation(e){return this.gl.getUniformLocation(this.program,e)}uniform1f(e,n){this.gl.uniform1f(e,n)}uniform1i(e,n){this.gl.uniform1i(e,n)}render(){const e=this.gl;e.clearColor(0,0,0,1),e.clear(e.COLOR_BUFFER_BIT),e.drawArrays(e.TRIANGLE_STRIP,0,4)}resize(e,n){this.canvas.width=e,this.canvas.height=n,this.gl.uniform2f(this.uResolutionLocation,e,n),this.gl.viewport(0,0,e,n)}createShader(e,n){const t=this.gl.createShader(e);if(!t)throw"shader can't created!";if(this.gl.shaderSource(t,n),this.gl.compileShader(t),!this.gl.getShaderParameter(t,this.gl.COMPILE_STATUS))throw console.log(n),`Shader compile error: ${this.gl.getShaderInfoLog(t)}`;return t}}},585:(e,n)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.stars=void 0,n.stars="\n\nfloat fbm(int count, vec3 p, float scaleBase, float scalePow, float depthBase, float depthPow) {\n    float res = 0.0;\n    for (int i = 0; i < 500; i++) {\n        if (i >= count) { break; }\n        float scale = scaleBase * pow(scalePow, float(i));\n        float depth = depthBase * pow(depthPow, float(i));\n        res += snoise(p * scale) * depth;\n    }\n    return res;\n}\n\n// 0.0～1.0未満\nfloat rand(float x) {\n    return fract(sin(x) * 10000.0);\n}\n\nfloat randRange(float x, float min, float max) {\n    return mix(min, max, rand(x));\n}\n\n// 天の川\nvec3 getMilkyWayColor(Ray ray) {\n    float noise = fbm(5, ray.direction, 0.9, 2.6, 1.0, 0.51) * 0.08;\n    float band = pow(0.07 * u_milkyScale / length(ray.direction.x + noise), 1.8);\n\n\n    vec3 baseCol = mix(vec3(0.6392, 0.8392, 1.0), vec3(0.1529, 0.1961, 0.2078), snoise(ray.direction * 10.1) * 0.5 + 0.5);\n    \n    float wayBrightness = clamp(fbm(8, ray.direction, 100.0, 2.0, 1.0, 0.52) * 0.09 + 0.2, 0.0, 1.0) * clamp(band, 0.0, 3.0);\n    vec3 col = baseCol * wayBrightness;\n\n    float noise2 = fbm(5, ray.direction, 0.55, 2.6, 1.0, 0.51) * 0.0015;\n    float band2 = pow(0.02 * u_milkyScale / length(ray.direction.x + noise + noise2), 1.8);\n    col -= vec3(0.9, 0.9, 1.0) * clamp(fbm(5, ray.direction, 40.0, 2.0, 1.0, 0.9) * 0.2 + 0.25, 0.0, 1.0) * clamp(band2, 0.0, 2.0) * 0.9;\n    col = max(col, 0.0) * 0.3;\n\n    float brightness = 0.0;\n    for (int i = 0; i < 20; i++) {\n        brightness += smoothstep(0.7, 1.0, snoise(ray.direction * (190.0 + float(i) * 5.0)));\n    }\n    col += baseCol * clamp(band, 0.0, 1.0) * brightness;\n\n    return col;\n}\n\n// 星たちの色\nvec3 getStarsColor(Ray ray) {\n    ray.direction *= rotateX(u_starXRot) * rotateZ(u_starZRot);\n    vec3 col = getMilkyWayColor(ray) * u_milkyBlend;\n\n    // 小さな星\n    float n = snoise(ray.direction * 180.0);\n    float brightness = smoothstep(0.7, 1.0, n);\n    col += mix(vec3(1.0, 0.9, 0.8), vec3(0.8, 0.9, 1.0), fract(n)) * brightness;\n\n    // 少し大きな星\n    for (int i = 0; i < 500; i++) {\n        float x = rand(float(i)) * 2.0 - 1.0;\n        float y = rand(float(i) * 1.123) * 2.0 - 1.0;\n        float z = rand(float(i) * 50.123) * 2.0 - 1.0;\n        vec3 starPos = normalize(vec3(x, y, z));\n\n        float d = dot(ray.direction, starPos);\n        float t = randRange(float(i) * 1234.0, 1.0, 0.99998);\n        d = smoothstep(t, 1.0, d);\n        if (d < 0.001) {\n            continue;\n        }\n\n        float angleFalloff = 1.0 - d; // 小さいほど中心\n        col += vec3(1.0, 1.0, 1.0) * (1.0 - smoothstep(0.00, 0.005, angleFalloff));\n        col += vec3(0.5, 0.6, 1.0) * (1.0 - smoothstep(0.005, 0.04, angleFalloff));\n        col += vec3(0.2, 0.3, 0.8) * (1.0 - smoothstep(0.02, 0.2, angleFalloff));\n    }\n\n    return col;\n}\n"},674:(e,n)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.simplexNoise=void 0,n.simplexNoise="\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n"},697:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.Renderer=void 0;const a=t(453),i=t(308);n.Renderer=class{constructor(e,n){this.uniform1fInfos=[{name:"u_cameraY",getValue:e=>e.cameraY},{name:"u_cameraXRot",getValue:e=>e.cameraXRot},{name:"u_mountainTime",getValue:e=>e.mountainTime},{name:"u_starZRot",getValue:e=>e.starZRot},{name:"u_starXRot",getValue:e=>e.starXRot},{name:"u_milkyScale",getValue:e=>e.milkyScale},{name:"u_milkyBlend",getValue:e=>e.milkyBlend},{name:"u_fbmScale",getValue:e=>e.fbmScale},{name:"u_fbmDepth",getValue:e=>e.fbmDepth},{name:"u_fbmThreshold",getValue:e=>e.fbmThreshold},{name:"u_cloudTime",getValue:e=>e.cloudTime},{name:"u_cloudMinY",getValue:e=>e.cloudMinY},{name:"u_cloudThickness",getValue:e=>e.cloudThickness},{name:"u_cloudAlphaScale",getValue:e=>e.cloudAlphaScale},{name:"u_waveFactor",getValue:e=>e.waveFactor},{name:"u_waveScale",getValue:e=>e.waveScale},{name:"u_waveTime",getValue:e=>e.waveTime}],this.uniform1iInfos=[{name:"u_cloudMaxSteps",getValue:e=>e.cloudMaxSteps},{name:"u_fbmMaxSteps",getValue:e=>e.fbmMaxSteps},{name:"u_fbmMinSteps",getValue:e=>e.fbmMinSteps},{name:"u_sampleCount",getValue:e=>e.sampleCount}],this.webGlCanvas=new a.WebGLCanvas(e,n,(0,i.buildFragmentShader)()),this.setupUniformLocations()}setupUniformLocations(){this.uniform1fInfos.forEach((e=>e.location=this.webGlCanvas.getUniformLocation(e.name))),this.uniform1iInfos.forEach((e=>e.location=this.webGlCanvas.getUniformLocation(e.name)))}render(e){this.webGlCanvas.isContextLost&&(this.webGlCanvas.setupWebGL(),this.setupUniformLocations()),this.uniform1fInfos.forEach((n=>this.webGlCanvas.uniform1f(n.location,n.getValue(e)))),this.uniform1iInfos.forEach((n=>this.webGlCanvas.uniform1i(n.location,n.getValue(e)))),this.webGlCanvas.render()}}},819:(e,n)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.matrix=void 0,n.matrix="\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        c, 0.0, -s,\n        0.0, 1.0, 0.0,\n        s, 0.0, c\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        c, -s, 0.0,\n        s,  c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n"}},n={};function t(a){var i=n[a];if(void 0!==i)return i.exports;var o=n[a]={exports:{}};return e[a](o,o.exports,t),o.exports}(()=>{const e=t(57),n=t(277),a=t(63);$((()=>new i));class i{constructor(){console.log("OK");const t=new e.PreviewSection,i=new a.RenderSection((()=>i.render(t)));$(document.body).append($("<main>").append((new n.ReadmeSection).element,t.element,i.element),$("<div>").css({flex:"1 1 0"}),$("<footer>").html('星空ジェネレーター Copyright (C) 2025 <a href="https://takabosoft.com/" target="_blank">Takabo Soft</a>'))}}})()})();